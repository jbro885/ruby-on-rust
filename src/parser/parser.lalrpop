use std::str::FromStr;
use parser::ast::*;

// use token::Token;

grammar;

// TODO multiple stmts
// REF in rustypop:
// stmts: () = {
//   stmt,
//   stmts stmt,
// };
// stmt: () = {
//   Let,
//   StmtItem,
//   "pub" StmtItem,
//   OuterAttrs StmtItem,
//   OuterAttrs "pub" StmtItem,
//   ExprStmtLike,
//   block,
//   ExprNoStmtLike ";",
//   ";",
// };

pub Program: Program = {
    StmtTopLevel => vec!(*<>),
    <stmts:Program> <stmt:StmtTopLevel> => {
        let mut new_stmts = stmts.to_vec();
        new_stmts.push(*stmt);
        new_stmts
    }
};

StmtTopLevel: Box<StmtTopLevel> = {
    // <class_def:ClassDefinition> => StmtTopLevel::ClassDefinition(class_def),
    <method_def:MethodDefinition> => Box::new(StmtTopLevel::MethodDefinition(*method_def)),
    <stmt:StmtWithinMethod> => Box::new(StmtTopLevel::StmtWithinMethod(*stmt)),
};

// // TODO
// // - identifier const
// // - keyword class and end, as extern tokens
// // - grammer for consts defs and method defs
// // - inline version
// ClassDefinition: Box<ClassDefinition> = {
//     "class" <i:IdConst> "end" => Box::new(ClassDefinition { class_name: (String::from(i)) }),
// };

// TODO
// - LOTS
MethodDefinition: Box<MethodDefinition> = {
    "def" <i:IdMethodName> <stmts:StmtsWithinMethod> "end" => Box::new(MethodDefinition { method_name: (String::from(i)), method_body: stmts }),
};

StmtsWithinMethod: StmtsWithinMethod = {
    StmtWithinMethod => vec!(*<>),
    <stmts:StmtsWithinMethod> <stmt:StmtWithinMethod> => {
        let mut new_stmts = stmts.to_vec();
        new_stmts.push(*stmt);
        new_stmts
    }
};

StmtWithinMethod: Box<StmtWithinMethod> = {
    <e:Expr> => Box::new(StmtWithinMethod::Expr(*e))
};

Expr: Box<Expr> = {
    ExprAssignment,
};

ExprAssignment: Box<Expr> = {
    ExprAddSub,
    <i:Identifier> "=" <r:ExprAddSub> => Box::new(Expr::Assignment(i, r))
};

ExprAddSub: Box<Expr> = {
    ExprMulDiv,
    <l:ExprAtom> "+" <r:ExprAddSub> => Box::new(Expr::Binary(l, Operator::Add, r)),
    <l:ExprAtom> "-" <r:ExprAddSub> => Box::new(Expr::Binary(l, Operator::Sub, r)),
};

ExprMulDiv: Box<Expr> = {
    ExprAtom,
    <l:ExprAtom> "*" <r:ExprAddSub> => Box::new(Expr::Binary(l, Operator::Mul, r)),
    <l:ExprAtom> "/" <r:ExprAddSub> => Box::new(Expr::Binary(l, Operator::Div, r)),
};

ExprAtom: Box<Expr> = {
    "(" <Expr> ")",
    Identifier => Box::new(Expr::Identifier(<>)),
    Number => Box::new(Expr::Number(<>)),
};

Identifier: String = {
    // TODO
    // IdGlobalVar,
    // IdInstanceVar,
    // IdClassVar,
    IdLocalVar,
    IdConst,
    IdMethodName
};

// TODO
// IdGlobalVar: String = { r"" => String::from(<>) };
// IdInstanceVar: String = { r"" => String::from(<>) };
// IdClassVar: String = { r"" => String::from(<>) };
IdLocalVar: String = { r"[a-z_]\w*" => String::from(<>) };
IdConst: String = { r"[A-Z]\w*" => String::from(<>) };
IdMethodName: String = { r"[a-zA-Z_][a-zA-Z0-9_=?!]*" => String::from(<>) };

Number: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};

// TODO must be a better way...
// https://github.com/nikomatsakis/lalrpop/issues/248
match {
    // KEYWORDS
    "def",
    "end"
} else {
    r"[a-zA-Z_][a-zA-Z0-9_=?!]*" // IdMethodName
} else {
    r"[A-Z]\w*" // IdConst
} else {
    _
}

// TODO extern tokens
// extern {
//     enum Token {
//         "(" => Token::ParenOpen,
//         ")" => Token::ParenClose,

//         "=" => Token::Equals,
//         "+" => Token::Plus,
//         "-" => Token::Dash,
//         "*" => Token::Star,
//         "/" => Token::Slash,

//         "class" => Token::KWClass,
//         "end" => Token::KWEnd
//     }
// }
